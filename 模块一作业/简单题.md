**1、*****\*Mybatis动态sql是做什么的？都有哪些动态sql？简述一下动态sql的执行原理？\****

对于比较复杂的业务，我们需要写比较复杂的sql语句，这时候就需要进行sql拼接，在拼接 SQL时 ，稍微不注意，由于引号、空格等缺失可能都会导致错误；Mybatis的动态sql功能可以解决这种问题，通过他Mybatis提供的 if, choose, when, otherwise, trim, where, set, foreach标签，可以对sql进行灵活拼接、组装，提高sql语句拼接的准确性。

 Mybatis中mapper.xml文件会在加载的时候全部解析为rootSqlNode节点

调用mapper的DAO接口时会代理其方法，封装参数，并传入StatementId （方法全限名）

根据StatementId获取到rootSqlNode节点，循环调用 MixedSqlNode方法，使用Ognl 解析的结果进行拼装返回

使用SqlSourceBuilder将#{} 中的内容解析，生成已经排序的参数List<ParameterMapping> parameterMappings并将 #{} 替换成 ?

最终调用JDBC中的preparedStatement.setXXX()方法，将已经排序的参数List<ParameterMapping> parameterMappings 中的参数按照顺序将?替换，便得到一个完整的SQL。

**2、*****\*Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\****

延迟加载是将数据加载时机推迟，在需要数据的时候，再去执行查询操作，返回需要的数据。在Mybatis的配置文件中可以配置是否启用延迟加载，lazyLoadingEnabled，它是延迟加载的全局开关，默认值是false；当开启时，所有关联对象都会延迟加载； 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps1.jpg) 

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps2.jpg) 

延迟加载主要是通过动态代理的形式实现，通过代理拦截到指定方法，执行数据加载。使用动态代理创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。

**3、*****\*Mybatis都有哪些Executor执行器？它们之间的区别是什么？\****

根据Mybatis源码看到org.apache.ibatis.session包下的ExecutorType，发现Mybatis有以下三种基本的Executor执行器:SimpleExecutor、ReuseExecutor、BatchExecutor；另外还有一个执行器CachingExecutor；如果启用了二级缓存，MyBatis在创建Executor的时候会对Executor进行装饰，也就是CachingExecutor。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps3.jpg) 

在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，defaultExecutorType该配置项用来配置默认的执行器；SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新；默认值为SIMPLE。

cacheEnabled	该配置项用来配置全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存；默认值为true。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps4.jpg) 

也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps5.jpg) 

SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。

CacheExecutor：它有一个重要属性delegate，它保存的是某类普通的Executor，值在构造时传入。执行数据库update操作时，它直接调用delegate的update方法，执行query方法时先尝试从cache中取值，取不到再调用delegate的查询方法，并将查询结果存入cache中。

**4、*****\*简述下Mybatis的一级、二级缓存（分别从存储结构、范围、失效场景。三个方面来作答）？\****

MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。默认情况下，只启用了本地的会话缓存，即一级缓存，它仅仅对一个会话(SqlSession)中的数据进行缓存。要启用全局的二级缓存，需要在mybatis-config.xml中添加配置cacheEnabled，默认是开启的；然后在SQL 映射文件中添加一行：<cache/>。二级缓存的范围是namespace级别的，可以被多个SqlSession共享(只要同一个接口里面的相同方法，都可以共享)。

查看源码发现Mybatis的一级缓存与二级缓存底层都是HashMap的结构。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps6.jpg) 

一级缓存失效场景：

在同一个sqlSession中，两次查询之间执行了映射语句文件中的 insert、update 或delete 语句，会刷新缓存；

在同一个sqlSession中，两次查询的条件不同；

两此查询所处的sqlSession不同；

手动清除缓存，执行sqlSession.clearCache()；关闭sqlSession，执行sqlSession.close()。

二级缓存失效场景：

某个SqlSession类的实例对象执行了映射语句文件中的 insert、update 或delete 语句，会刷新缓存；

同一个namespace下，两次查询的条件不同。

**5、*****\*简述Mybatis的插件运行原理，以及如何编写一个插件？\****

Mybatis支持用插件在已映射语句执行过程中的某一点进行拦截调用，对于mybatis来说插件就是拦截器，用来增强核心对象的功能，增强的本质上是借助于底层的动态代理实现的，也就是说，Mybatis中的四大对象都是代理对象。

Mybatis在创建四大对象的时候：

1、每个创建出来的对象不是直接返回的，而是

 interceptorChain.pluginAll(parameterHandler);

2、获取到所有的Interceptor（拦截器）（插件需要实现的接口）；

调用interceptor.plugin(target);返回target包装后的对象

3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP（面向切面）我们的插件可以为四大对象创建出代理对象；代理对象就可以拦截到四大对象的每一个执行；

思路：实现Interceptor类实现自定义拦截器，通过初始化配置文件把所有的自定义拦截器放入InterceptorChain(拦截器链)中，然后通过JDK动态代理为实例生成代理类，实现依次拦截处理。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps7.jpg) 

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps8.jpg) 

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps9.jpg) 

插件编写：

定义一个插件，并实现 Interceptor 接口，指定想要拦截的方法签名，使用时需要将该插件配置到sqlMapConfig.xml文件中。

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps10.jpg) 

![img](file:///C:\Users\lzz\AppData\Local\Temp\ksohtml14252\wps11.jpg) ![]()